<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Test</title>
	<link href="mocha.css" rel="stylesheet">
</head>
<body>
	<div id="mocha"></div>

	<input id="tags">
	<script src="mocha/mocha.js"></script>
	<script src="proclaim/lib/proclaim.js"></script>
	<script src="async-define/async-define.js"></script>
	<script src="events-amd/events-amd.js"></script>
	<script src="doc-amd/doc.js"></script>
	<script src="tag.js"></script>

	<script>
		var COMMA = 188,
			ENTER = 13,
			TAB = 9,
			BACKSPACE = 8,
			LEFT_KEY = 37,
			RIGHT_KEY = 39,
			CHAR_A = 65;
		var type = function(element, keyCode) {
			var evt;
			try {
				evt = new Event('keydown');
			} catch (e) {
				evt = document.createEvent('Event');
				evt.initEvent('keydown', true, false);
			}
			evt.which = keyCode;
			evt.keyCode = keyCode;

			element.dispatchEvent(evt);
		};
	</script>

	<script>
		var assert = proclaim;
		mocha.ui('bdd');

		define(['doc', 'tag'], function($, tag) {
			var input = $('#tags');

			describe('Tagify method', function() {
				beforeEach(function() {
					input.val('');
				});

				afterEach(function() {
					input.off('keydown');
				});

				it('should create a single tag from a filled input', function() {
					input.val('tag1');
					var tagged = tag.tagify('#tags');
					assert.deepEqual(tagged.tags(), ['tag1']);
				});
				it('should create two tags from a filled input, splitted with comma', function() {
					input.val('tag1,another-tag');
					var tagged = tag.tagify('#tags');
					assert.deepEqual(tagged.tags(), ['tag1', 'another-tag']);
				});
				it('should create two tags from a filled input, splitted with a spaced comma', function() {
					input.val('tag1, another-tag');
					var tagged = tag.tagify('#tags');
					assert.deepEqual(tagged.tags(), ['tag1', 'another-tag']);
				});
				it('should create two tags from a filled input, one of them with spaces, splitted with a spaced comma', function() {
					input.val('tag1, another tag');
					var tagged = tag.tagify('#tags');
					assert.deepEqual(tagged.tags(), ['tag1', 'another tag']);
				});
				it('should create some tags from a filled input, removing empty tags', function() {
					input.val('tag1, another tag, tag2,, another another , ,');
					var tagged = tag.tagify('#tags');
					assert.deepEqual(tagged.tags(), ['tag1', 'another tag', 'tag2', 'another another']);
				});
			});

			describe('Typing in a tagified input', function() {
				beforeEach(function() {
					input.val('');
				});

				afterEach(function() {
					input.off('keydown');
				});

				it('should create a new tag when a comma is typed', function() {
					var tagged = tag.tagify('#tags');
					input.val('tag1');
					assert.lengthEquals(tagged.tags(), 0);
					type(input.first(), COMMA);
					assert.deepEqual(tagged.tags(), ['tag1']);
				});

				it('should not duplicate tag', function() {
					input.val('tag1');
					var tagged = tag.tagify('#tags');
					type(input.first(), COMMA);
					assert.deepEqual(tagged.tags(), ['tag1']);
				});

				it('should create a new tag when enter is typed', function() {
					var tagged = tag.tagify('#tags');
					input.val('tag1');
					assert.lengthEquals(tagged.tags(), 0);
					type(input.first(), ENTER);
					assert.deepEqual(tagged.tags(), ['tag1']);
				});

				it('should create a new tag when tab is typed', function() {
					var tagged = tag.tagify('#tags');
					input.val('tag1');
					assert.lengthEquals(tagged.tags(), 0);
					type(input.first(), TAB);
					assert.deepEqual(tagged.tags(), ['tag1']);
				});

				it('should remove last tag when backspace is typed', function() {
					input.val('tag1, tag-to-remove');
					var tagged = tag.tagify('#tags');
					assert.lengthEquals(tagged.tags(), 2);
					type(input.first(), BACKSPACE);
					assert.deepEqual(tagged.tags(), ['tag1']);
				});

				it('should do nothing when backspace is typed and there are no tags', function() {
					var tagged = tag.tagify('#tags');
					assert.lengthEquals(tagged.tags(), 0);
					type(input.first(), BACKSPACE);
					assert.lengthEquals(tagged.tags(), 0);
				});

				it('should add all tags in the input when comma is typed', function() {
					var tagged = tag.tagify('#tags');
					assert.lengthEquals(tagged.tags(), 0);
					input.val('tag1, another tag');
					type(input.first(), COMMA);
					assert.deepEqual(tagged.tags(), ['tag1', 'another tag']);
				});

				it('should add all unique tags in the input when comma is typed and there are repeated tags', function() {
					var tagged = tag.tagify('#tags');
					assert.lengthEquals(tagged.tags(), 0);
					input.val('tag1, another tag, tag1, yet another');
					type(input.first(), COMMA);
					assert.deepEqual(tagged.tags(), ['tag1', 'another tag', 'yet another']);
				});
			});

			describe('Selecting tags of a tagified input', function() {
				it('should have no selected tags after activated', function() {
					input.val('tag1, tag-to-remove');
					var tagged = tag.tagify('#tags');
					assert.isNull(tagged.selected());
				});

				it('should not select tags when pressing left key if input is filled', function() {
					input.val('tag1, another');
					var tagged = tag.tagify('#tags');
					input.val('tag2')
					type(input.first(), LEFT_KEY);
					assert.isNull(tagged.selected());
				});

				it('should not select tags if none is selected and right key is pressed', function() {
					input.val('tag1, tag-to-remove');
					var tagged = tag.tagify('#tags');
					assert.isNull(tagged.selected());
					type(input.first(), RIGHT_KEY);
					assert.isNull(tagged.selected());
				});

				it('should not select tags when pressing right key if input is filled', function() {
					input.val('tag1, another');
					var tagged = tag.tagify('#tags');
					input.val('tag2')
					type(input.first(), RIGHT_KEY);
					assert.isNull(tagged.selected());
				});

				it('should select the last tag when pressing left key if input is empty', function() {
					input.val('tag1, another');
					var tagged = tag.tagify('#tags');
					input.val('')
					type(input.first(), LEFT_KEY);
					assert.equal(tagged.selected(), 'another');
				});

				it('should select the tag before when pressing left key with a tag selected', function() {
					input.val('tag1, another');
					var tagged = tag.tagify('#tags');
					input.val('')
					type(input.first(), LEFT_KEY);
					type(input.first(), LEFT_KEY);
					assert.equal(tagged.selected(), 'tag1');
				});

				it('should keep the first tag selected when pressing left key with the first tag selected', function() {
					input.val('tag1, another');
					var tagged = tag.tagify('#tags');
					input.val('')
					type(input.first(), LEFT_KEY);
					type(input.first(), LEFT_KEY);
					type(input.first(), LEFT_KEY);
					assert.equal(tagged.selected(), 'tag1');
				});

				it('should deselect the last tag if it was previously selected when the right key is pressed', function() {
					input.val('tag1, another');
					var tagged = tag.tagify('#tags');
					input.val('')
					type(input.first(), LEFT_KEY);
					type(input.first(), RIGHT_KEY);
					assert.isNull(tagged.selected());
				});

				it('should select the next tag when the right key is pressed and there is next tag', function() {
					input.val('tag1, another');
					var tagged = tag.tagify('#tags');
					input.val('')
					type(input.first(), LEFT_KEY);
					type(input.first(), LEFT_KEY);
					type(input.first(), RIGHT_KEY);
					assert.equal(tagged.selected(), 'another');
				});
			});
		});
	</script>

	<script>
		if (window.mochaPhantomJS) {
			mochaPhantomJS.run();
		} else {
			mocha.run();
		}
	</script>
</body>
</html>
